// The MIT License
//
// Copyright (c) 2025 Temporal Technologies Inc.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package tests

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/suite"
	omeskitchensink "github.com/temporalio/omes/loadgen/kitchensink"
	sdkclient "go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/server/common/log/tag"
	"go.temporal.io/server/tools/catch/pitcher"
	"go.temporal.io/server/tools/catch/pitcher"
	"go.temporal.io/server/tools/catch/skipper"
	"go.temporal.io/server/tests/kitchensink"
	"go.temporal.io/server/tests/testcore"
)

// CatchExampleSuite demonstrates the complete CATCH workflow
// This serves as both a test and comprehensive documentation of how to use
// the CATCH system for chaos engineering and property-based testing.
type CatchExampleSuite struct {
	testcore.FunctionalTestBase
}

func TestCatchExample(t *testing.T) {
	suite.Run(t, new(CatchExampleSuite))
}

// TestCompleteWorkflow demonstrates the full CATCH workflow from start to finish
func (s *CatchExampleSuite) TestCompleteWorkflow() {
	s.Logger.Info("=== Starting Complete CATCH Workflow Example ===")

	// Step 1: Initialize the Play Library
	// The play library contains pre-built test scenarios
	s.Logger.Info("Step 1: Initializing play library")
	library := play.StandardPlayLibrary()
	s.Logger.Info("Play library initialized",
		tag.NewInt("totalPlays", len(library.All())))

	// Step 2: Configure the Skipper
	// The skipper intelligently selects which plays to run
	s.Logger.Info("Step 2: Configuring skipper with coverage-driven strategy")
	skipperConfig := skipper.DefaultConfig()
	skipperConfig.Strategy = skipper.StrategyCoverageDriven
	skipperConfig.Seed = 42 // Fixed seed for reproducibility
	skipperConfig.CategoryWeights = map[string]float64{
		"resilience": 3.0, // Prioritize resilience tests
		"baseline":   1.0,
		"performance": 2.0,
	}

	skip := skipper.NewSkipper(s.Logger, library, skipperConfig)
	s.Logger.Info("Skipper configured",
		tag.NewAnyTag("strategy", skipperConfig.Strategy))

	// Step 3: Register Workflows and Start Worker
	// The worker executes our kitchensink workflow
	s.Logger.Info("Step 3: Starting worker with kitchensink workflow")
	w := worker.New(s.SdkClient(), s.TaskQueue(), worker.Options{})
	kitchensink.RegisterWorkflows(w)
	s.NoError(w.Start())
	defer w.Stop()
	s.Logger.Info("Worker started successfully")

	// Step 4: Execute Plays Until Coverage Goal
	// Run plays until we reach target coverage or max iterations
	s.Logger.Info("Step 4: Executing plays with coverage tracking")
	maxIterations := 10
	targetCoverage := 30.0 // Target 30% coverage for this example

	successCount := 0
	failureCount := 0

	for i := 0; i < maxIterations; i++ {
		s.Logger.Info("=== Iteration Start ===",
			tag.NewInt("iteration", i+1),
			tag.NewInt("maxIterations", maxIterations))

		// Step 4a: Select Next Play
		selectedPlay := skip.SelectPlay()
		s.NotNil(selectedPlay, "Skipper should select a play")

		s.Logger.Info("Play selected",
			tag.NewStringTag("play", selectedPlay.Name),
			tag.NewStringTag("description", selectedPlay.Description),
			tag.NewAnyTag("tags", selectedPlay.Tags))

		// Step 4b: Configure Pitcher with Play's Pitches
		s.Logger.Info("Configuring pitcher with fault injection")
		for idx, pitch := range selectedPlay.Pitches {
			s.Logger.Info("Configuring pitch",
				tag.NewInt("pitchIndex", idx),
				tag.NewStringTag("target", pitch.Target),
				tag.NewStringTag("action", pitch.Config.Action),
				tag.NewStringTag("description", pitch.Description))
			s.ConfigurePitcher(pitch.Target, pitch.Config)
		}

		// Step 4c: Execute Workflow
		s.Logger.Info("Executing workflow")
		ctx, cancel := context.WithTimeout(context.Background(),
			selectedPlay.ExpectedOutcome.MaxDuration)

		startTime := time.Now()

		workflowInput := &omeskitchensink.WorkflowInput{
			InitialActions: []*omeskitchensink.ActionSet{
				omeskitchensink.NoOpSingleActivityActionSet(),
			},
		}

		we, err := s.SdkClient().ExecuteWorkflow(ctx, sdkclient.StartWorkflowOptions{
			TaskQueue: s.TaskQueue(),
		}, kitchensink.KitchenSinkWorkflow, workflowInput)

		success := false

		if err != nil {
			s.Logger.Warn("Failed to start workflow",
				tag.NewErrorTag("error", err))
		} else {
			err = we.Get(ctx, nil)
			if err != nil {
				s.Logger.Warn("Workflow execution failed",
					tag.NewErrorTag("error", err))
			} else {
				success = true
				s.Logger.Info("Workflow completed",
					tag.NewDurationTag("duration", time.Since(startTime)))
			}
		}

		cancel()

		// Step 4d: Record Execution for Coverage Tracking
		skip.RecordExecution(selectedPlay, success)

		if success {
			successCount++
			s.Logger.Info("Play succeeded",
				tag.NewStringTag("play", selectedPlay.Name))
		} else {
			failureCount++
			s.Logger.Warn("Play failed",
				tag.NewStringTag("play", selectedPlay.Name))
		}

		// Step 4e: Reset Pitcher for Next Iteration
		s.GetTestCluster().Pitcher().Reset()
		s.Logger.Info("Pitcher reset for next iteration")

		// Step 4f: Check Coverage Progress
		report := skip.GetCoverageReport()
		currentCoverage := report.CoveragePercentage()

		s.Logger.Info("Coverage progress",
			tag.NewInt("iteration", i+1),
			tag.NewInt("uniquePlaysRun", report.UniquePlaysRun),
			tag.NewInt("totalExecutions", report.TotalExecutions),
			tag.NewFloat64("coverage", currentCoverage),
			tag.NewInt("successCount", successCount),
			tag.NewInt("failureCount", failureCount))

		// Check if we've reached target coverage
		if currentCoverage >= targetCoverage {
			s.Logger.Info("Target coverage reached!",
				tag.NewFloat64("targetCoverage", targetCoverage),
				tag.NewFloat64("actualCoverage", currentCoverage),
				tag.NewInt("totalIterations", i+1))
			break
		}

		s.Logger.Info("=== Iteration End ===")
	}

	// Step 5: Generate Final Report
	s.Logger.Info("=== Step 5: Generating Final Report ===")
	finalReport := skip.GetCoverageReport()

	s.Logger.Info("=== FINAL COVERAGE REPORT ===",
		tag.NewInt("totalPlaysInLibrary", finalReport.TotalPlaysInLib),
		tag.NewInt("uniquePlaysExecuted", finalReport.UniquePlaysRun),
		tag.NewInt("totalExecutions", finalReport.TotalExecutions),
		tag.NewFloat64("coveragePercentage", finalReport.CoveragePercentage()),
		tag.NewInt("successfulExecutions", successCount),
		tag.NewInt("failedExecutions", failureCount))

	// Log individual play execution counts
	s.Logger.Info("=== PLAY EXECUTION COUNTS ===")
	for playName, count := range finalReport.ExecutedPlays {
		s.Logger.Info("Play execution count",
			tag.NewStringTag("play", playName),
			tag.NewInt("executionCount", count))
	}

	// Log tag coverage
	s.Logger.Info("=== TAG COVERAGE ===")
	for tagName, count := range finalReport.TagCoverage {
		s.Logger.Info("Tag coverage",
			tag.NewStringTag("tag", tagName),
			tag.NewInt("coverageCount", count))
	}

	// Step 6: Validate Results
	s.Logger.Info("=== Step 6: Validating Results ===")
	s.Greater(finalReport.UniquePlaysRun, 0, "Should have executed at least one play")
	s.Greater(successCount, 0, "Should have at least some successful executions")
	s.Logger.Info("Validation complete - all assertions passed")

	s.Logger.Info("=== Complete CATCH Workflow Example Finished Successfully ===")
}

// TestManualPlaySelection demonstrates manually selecting and executing specific plays
func (s *CatchExampleSuite) TestManualPlaySelection() {
	s.Logger.Info("=== Manual Play Selection Example ===")

	library := play.StandardPlayLibrary()

	// Start worker
	w := worker.New(s.SdkClient(), s.TaskQueue(), worker.Options{})
	kitchensink.RegisterWorkflows(w)
	s.NoError(w.Start())
	defer w.Stop()

	// Manually select specific plays to execute
	playNames := []string{
		"SimpleBaseline",           // Baseline - no faults
		"MatchingFailureRetry",     // Test matching resilience
		"HighMatchingLatency",      // Test latency handling
		"ServiceUnavailable",       // Test unavailable error handling
	}

	s.Logger.Info("Executing manually selected plays",
		tag.NewInt("playCount", len(playNames)))

	for _, playName := range playNames {
		testPlay, ok := library.Get(playName)
		s.Require().True(ok, "Play %s should exist in library", playName)

		s.Logger.Info("Executing play",
			tag.NewStringTag("play", playName),
			tag.NewStringTag("description", testPlay.Description))

		// Configure pitcher
		for _, pitch := range testPlay.Pitches {
			s.Logger.Info("Configuring pitch",
				tag.NewStringTag("target", pitch.Target),
				tag.NewStringTag("action", pitch.Config.Action))
			s.ConfigurePitcher(pitch.Target, pitch.Config)
		}

		// Execute workflow
		ctx, cancel := context.WithTimeout(context.Background(),
			testPlay.ExpectedOutcome.MaxDuration)

		workflowInput := &omeskitchensink.WorkflowInput{
			InitialActions: []*omeskitchensink.ActionSet{
				omeskitchensink.NoOpSingleActivityActionSet(),
			},
		}

		we, err := s.SdkClient().ExecuteWorkflow(ctx, sdkclient.StartWorkflowOptions{
			TaskQueue: s.TaskQueue(),
		}, kitchensink.KitchenSinkWorkflow, workflowInput)
		s.NoError(err, "Should start workflow for play %s", playName)

		err = we.Get(ctx, nil)
		s.NoError(err, "Workflow should complete for play %s", playName)

		s.Logger.Info("Play completed successfully",
			tag.NewStringTag("play", playName))

		cancel()

		// Reset pitcher for next play
		s.GetTestCluster().Pitcher().Reset()
	}

	s.Logger.Info("=== Manual Play Selection Example Complete ===")
}

// TestCategoryBasedExecution demonstrates executing plays by category
func (s *CatchExampleSuite) TestCategoryBasedExecution() {
	s.Logger.Info("=== Category-Based Execution Example ===")

	library := play.StandardPlayLibrary()

	// Start worker
	w := worker.New(s.SdkClient(), s.TaskQueue(), worker.Options{})
	kitchensink.RegisterWorkflows(w)
	s.NoError(w.Start())
	defer w.Stop()

	// Execute all plays in the "resilience" category
	resiliencePlays := library.GetByCategory("resilience")
	s.Logger.Info("Executing resilience plays",
		tag.NewInt("playCount", len(resiliencePlays)))

	successCount := 0
	for _, testPlay := range resiliencePlays {
		s.Logger.Info("Executing resilience play",
			tag.NewStringTag("play", testPlay.Name),
			tag.NewAnyTag("tags", testPlay.Tags))

		// Configure pitcher
		for _, pitch := range testPlay.Pitches {
			s.ConfigurePitcher(pitch.Target, pitch.Config)
		}

		// Execute workflow
		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)

		workflowInput := &omeskitchensink.WorkflowInput{
			InitialActions: []*omeskitchensink.ActionSet{
				omeskitchensink.NoOpSingleActivityActionSet(),
			},
		}

		we, err := s.SdkClient().ExecuteWorkflow(ctx, sdkclient.StartWorkflowOptions{
			TaskQueue: s.TaskQueue(),
		}, kitchensink.KitchenSinkWorkflow, workflowInput)

		if err == nil {
			err = we.Get(ctx, nil)
			if err == nil {
				successCount++
				s.Logger.Info("Resilience play succeeded",
					tag.NewStringTag("play", testPlay.Name))
			}
		}

		cancel()
		s.GetTestCluster().Pitcher().Reset()
	}

	s.Logger.Info("=== Category-Based Execution Complete ===",
		tag.NewInt("totalPlays", len(resiliencePlays)),
		tag.NewInt("successCount", successCount))
}

// TestWeightedStrategy demonstrates using weighted play selection
func (s *CatchExampleSuite) TestWeightedStrategy() {
	s.Logger.Info("=== Weighted Strategy Example ===")

	library := play.StandardPlayLibrary()

	// Configure skipper with weighted strategy
	config := skipper.DefaultConfig()
	config.Strategy = skipper.StrategyWeighted
	config.Seed = 123
	config.CategoryWeights = map[string]float64{
		"resilience":  5.0, // Very high priority
		"performance": 2.0, // Medium priority
		"baseline":    0.5, // Low priority
	}

	skip := skipper.NewSkipper(s.Logger, library, config)
	s.Logger.Info("Skipper configured with weighted strategy",
		tag.NewAnyTag("weights", config.CategoryWeights))

	// Start worker
	w := worker.New(s.SdkClient(), s.TaskQueue(), worker.Options{})
	kitchensink.RegisterWorkflows(w)
	s.NoError(w.Start())
	defer w.Stop()

	// Execute 5 plays with weighted selection
	playSelections := make(map[string]int)

	for i := 0; i < 5; i++ {
		selectedPlay := skip.SelectPlay()
		s.NotNil(selectedPlay)

		playSelections[selectedPlay.Name]++

		s.Logger.Info("Weighted selection",
			tag.NewInt("iteration", i+1),
			tag.NewStringTag("play", selectedPlay.Name),
			tag.NewAnyTag("tags", selectedPlay.Tags))

		// Configure and execute
		for _, pitch := range selectedPlay.Pitches {
			s.ConfigurePitcher(pitch.Target, pitch.Config)
		}

		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)

		workflowInput := &omeskitchensink.WorkflowInput{
			InitialActions: []*omeskitchensink.ActionSet{
				omeskitchensink.NoOpSingleActivityActionSet(),
			},
		}

		we, _ := s.SdkClient().ExecuteWorkflow(ctx, sdkclient.StartWorkflowOptions{
			TaskQueue: s.TaskQueue(),
		}, kitchensink.KitchenSinkWorkflow, workflowInput)

		success := false
		if we != nil {
			err := we.Get(ctx, nil)
			success = (err == nil)
		}

		skip.RecordExecution(selectedPlay, success)
		cancel()
		s.GetTestCluster().Pitcher().Reset()
	}

	// Log selection distribution
	s.Logger.Info("=== Play Selection Distribution ===")
	for playName, count := range playSelections {
		s.Logger.Info("Play selection count",
			tag.NewStringTag("play", playName),
			tag.NewInt("selectedCount", count))
	}

	s.Logger.Info("=== Weighted Strategy Example Complete ===")
}

// TestCustomPlayCreation demonstrates creating a custom play
func (s *CatchExampleSuite) TestCustomPlayCreation() {
	s.Logger.Info("=== Custom Play Creation Example ===")

	library := play.NewPlayLibrary()

	// Create a custom play
	customPlay := &play.Play{
		Name:        "CustomHighLatencyTest",
		Description: "Custom test for very high latency scenarios",
		Pitches: []play.Pitch{
			{
				Target: "matchingservice.AddWorkflowTask",
				Config: pitcher.PitchConfig{
					Action: "delay",
					Params: map[string]any{
						"duration": 3 * time.Second,
						"jitter":   500 * time.Millisecond,
					},
				},
				Description: "3 second delay on task addition",
			},
			{
				Target: "historyservice.RespondWorkflowTaskCompleted",
				Config: pitcher.PitchConfig{
					Action:      "delay",
					Probability: 0.2,
					Params: map[string]any{
						"duration": 1 * time.Second,
					},
				},
				Description: "20% chance of 1 second delay",
			},
		},
		Workload: play.WorkloadConfig{
			Type:    "kitchensink",
			Variant: "simple",
		},
		ExpectedOutcome: play.OutcomeConfig{
			ExpectedState:          "completed",
			MaxDuration:            90 * time.Second,
			AllowedViolations:      []string{},
			MinActivitiesCompleted: 1,
		},
		Tags: []string{"custom", "latency", "performance"},
	}

	// Register the custom play
	library.Register(customPlay)

	s.Logger.Info("Custom play created and registered",
		tag.NewStringTag("play", customPlay.Name),
		tag.NewStringTag("description", customPlay.Description),
		tag.NewAnyTag("tags", customPlay.Tags))

	// Verify it's in the library
	retrievedPlay, ok := library.Get("CustomHighLatencyTest")
	s.True(ok, "Custom play should be retrievable")
	s.Equal(customPlay.Name, retrievedPlay.Name)

	s.Logger.Info("=== Custom Play Creation Example Complete ===")
}
